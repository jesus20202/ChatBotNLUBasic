üõ†Ô∏è PLAN DE DESARROLLO - Implementaci√≥n Paso a Paso
üìã SITUACI√ìN ACTUAL
‚úÖ Base de datos creada con informaci√≥n
‚úÖ Estructura de carpetas y archivos lista
‚úÖ Decisi√≥n: usar huggingface_hub SDK
üöÄ PLAN DE DESARROLLO POR FASES
FASE 1: Base FastAPI + Conexi√≥n BD (30 min)
1.1 Configuraci√≥n inicial
python# main.py - Setup b√°sico FastAPI
- Crear app FastAPI
- Configurar CORS
- Endpoint b√°sico de health check
- Servidor de archivos est√°ticos
1.2 Conexi√≥n a Base de Datos
python# database/connection.py
- Configurar SQLAlchemy engine
- Session maker
- Dependency para get_db()

# models/database.py  
- Definir todos los modelos SQLAlchemy
- Relaciones entre tablas
- M√©todos b√°sicos
1.3 Testing conexi√≥n
python# Endpoint GET /productos - listar todos
# Verificar que la conexi√≥n BD funciona

FASE 2: Cliente Hugging Face (20 min)
2.1 Configuraci√≥n HF Client
python# llm/ollama_client.py
from huggingface_hub import InferenceClient

class OllamaClient:
    def __init__(self, model_name, api_key):
        self.client = InferenceClient(model_name, token=api_key)
    
    async def generate_response(self, prompt: str) -> str:
        # Implementar llamada al modelo
        # Manejo de errores
        # Retry logic
2.2 Testing LLM
python# Endpoint POST /test-llm
# Probar que el modelo responde correctamente

FASE 3: Sistema NLU B√°sico (45 min)
3.1 Clasificador de Intenciones
python# nlu/intent_classifier.py
class IntentClassifier:
    def __init__(self):
        # Patrones regex/keywords por intenci√≥n
        self.patterns = {
            'buscar_producto': ['buscar', 'encontrar', 'mostrar', 'ver'],
            'recomendar_categoria': ['recomendar', 'sugerir', 'qu√© hay'],
            'comparar_precios': ['comparar', 'precio', 'm√°s barato'],
            'info_producto': ['informaci√≥n', 'detalles', 'caracter√≠sticas'],
            'saludo': ['hola', 'buenos d√≠as', 'hey'],
            'ayuda': ['ayuda', 'help', 'no entiendo']
        }
    
    def classify(self, text: str) -> tuple[str, float]:
        # L√≥gica de clasificaci√≥n simple pero efectiva
        # Retornar (intenci√≥n, confidence)
3.2 Extractor de Entidades
python# nlu/entity_extractor.py
class EntityExtractor:
    def extract(self, text: str) -> dict:
        # Extraer marca, categor√≠a, rango_precio
        # Usar regex y listas predefinidas
        # Retornar dict con entidades encontradas
3.3 Coordinator NLU
python# nlu/__init__.py
class NLUProcessor:
    def __init__(self):
        self.intent_classifier = IntentClassifier()
        self.entity_extractor = EntityExtractor()
    
    def process(self, text: str) -> dict:
        # Procesar intenci√≥n + entidades
        # Retornar resultado estructurado

FASE 4: Queries Din√°micas BD (30 min)
4.1 Query Builder
python# database/queries.py
class ProductQueries:
    def __init__(self, db):
        self.db = db
    
    def search_by_intent(self, intent: str, entities: dict) -> list:
        # Switch/case por intenci√≥n
        # Construir queries din√°micas
        # Retornar resultados relevantes
    
    def get_recommendations(self, categoria: str, limit: int = 5):
        # L√≥gica de recomendaciones
    
    def compare_prices(self, entities: dict):
        # Comparar precios por criterios
4.2 Context Builder
python# llm/prompt_builder.py
class PromptBuilder:
    def build_context(self, intent: str, entities: dict, db_results: list) -> str:
        # Construir contexto espec√≠fico por intenci√≥n
        # Formatear resultados de BD
        # Crear prompt optimizado para el LLM

FASE 5: API Endpoints Core (25 min)
5.1 Endpoint principal de chat
python# main.py
@app.post("/chat")
async def chat_endpoint(message: str, session_id: str = None):
    # 1. Procesar con NLU
    # 2. Consultar BD
    # 3. Construir prompt
    # 4. Llamar LLM
    # 5. Guardar en BD
    # 6. Retornar respuesta
5.2 Endpoints de utilidad
python# GET /categorias - listar categor√≠as
# GET /productos/{categoria} - productos por categor√≠a  
# GET /stats - estad√≠sticas b√°sicas

FASE 6: Frontend B√°sico (40 min)
6.1 HTML Template
html<!-- templates/index.html -->
- Chat interface limpia
- Input para mensajes
- √Årea de conversaci√≥n
- Indicador de "escribiendo..."
- Responsive design
6.2 CSS Styling
css/* static/css/style.css */
- Estilo moderno para chat
- Colores profesionales
- Animaciones suaves
- Mobile-first design
6.3 JavaScript Chat
javascript// static/js/chat.js
- Manejo de env√≠o de mensajes
- Fetch API para llamadas
- Actualizaci√≥n DOM
- Manejo de errores

FASE 7: WebSockets (30 min)
7.1 WebSocket Manager
python# websocket/manager.py
class ConnectionManager:
    def __init__(self):
        self.active_connections = []
    
    async def connect(self, websocket, session_id):
        # Manejar nuevas conexiones
    
    async def send_message(self, message, session_id):
        # Enviar mensajes a sesi√≥n espec√≠fica
7.2 WebSocket Endpoint
python# main.py
@app.websocket("/ws/{session_id}")
async def websocket_endpoint(websocket: WebSocket, session_id: str):
    # Manejar comunicaci√≥n en tiempo real
    # Integrar con sistema de chat
7.3 Frontend WebSocket
javascript// Actualizar chat.js para usar WebSockets
// Comunicaci√≥n bidireccional
// Reconexi√≥n autom√°tica

FASE 8: Logging y M√©tricas (20 min)
8.1 Sistema de Logging
python# Logging en cada endpoint
# M√©tricas de tiempo de respuesta
# Guardado en tablas correspondientes
8.2 Dashboard B√°sico
html<!-- templates/dashboard.html -->
- Estad√≠sticas de uso
- Intenciones m√°s detectadas
- Productos m√°s consultados

FASE 9: Testing y Optimizaci√≥n (30 min)
9.1 Testing Manual
python# Probar todos los flujos
# Diferentes tipos de mensajes
# Casos edge (sin resultados, errores)
9.2 Optimizaci√≥n
python# Manejo de errores robusto
# Timeouts apropiados
# Validaci√≥n de datos

FASE 10: Deploy Preparation (15 min)
10.1 Configuraci√≥n Producci√≥n
python# requirements.txt completo
# Variables de entorno
# Configuraci√≥n para Render
10.2 Documentaci√≥n
markdown# README.md con:
- Instrucciones de instalaci√≥n
- Endpoints disponibles
- Ejemplos de uso

‚è±Ô∏è CRONOGRAMA ESTIMADO
Total: ~4.5 horas de desarrollo

Fase 1-2: 50 min (Base + LLM)
Fase 3-4: 75 min (NLU + BD)
Fase 5-6: 65 min (API + Frontend)
Fase 7-8: 50 min (WebSockets + Logging)
Fase 9-10: 45 min (Testing + Deploy)

üéØ PRIORIDADES
Si tienes poco tiempo, enf√≥cate en:

Fase 1-2 (Base funcional)
Fase 3-4 (NLU + BD)
Fase 5 (API core)
Fase 6 (Frontend b√°sico)

Las fases 7-10 son para impresionar m√°s, pero no cr√≠ticas para demo funcional.
¬øPor cu√°l fase empezamos? ¬øTienes alguna preferencia en el orden?